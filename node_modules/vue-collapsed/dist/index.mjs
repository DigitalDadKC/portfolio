import { defineComponent as $, toRef as H, computed as x, ref as S, shallowRef as E, onMounted as I, watch as _, openBlock as L, createBlock as M, resolveDynamicComponent as U, normalizeStyle as O, withCtx as k, renderSlot as q, normalizeProps as z, guardReactiveProps as B } from "vue";
const R = "--vc-auto-duration", P = `height var(${R}) cubic-bezier(0.33, 1, 0.68, 1)`, p = { padding: 0 }, V = 300, Y = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  border: "0"
};
function C(a) {
  return a.value ? parseFloat(getComputedStyle(a.value).height) : 0;
}
function D(a) {
  if (!a.value)
    return {};
  const { transition: n } = getComputedStyle(a.value);
  return n === "all 0s ease 0s" || n === "all" ? { transition: P } : { transition: n };
}
function b(a) {
  if (!a.value)
    return !0;
  const { transition: n } = getComputedStyle(a.value);
  return typeof window.requestAnimationFrame > "u" || window.matchMedia("(prefers-reduced-motion: reduce)").matches || n.includes("none") || n.includes("height 0s");
}
function K(a = 0) {
  if (a === 0)
    return 0;
  const n = a / 36, o = Math.round((4 + 15 * n ** 0.25 + n / 5) * 10);
  return Number.isFinite(o) ? o : 0;
}
const J = /* @__PURE__ */ $({
  inheritAttrs: !0,
  __name: "Collapse",
  props: {
    when: { type: Boolean },
    baseHeight: { default: 0 },
    as: { default: "div" }
  },
  emits: ["collapse", "expand", "collapsed", "expanded"],
  setup(a, { emit: n }) {
    const o = a, u = n, i = H(o, "when"), l = H(o, "baseHeight"), h = x(() => ({ overflow: "hidden", height: `${l.value}px` })), v = x(() => ({
      ...p,
      ...l.value === 0 ? { display: "none" } : h.value
    })), t = S(null), f = S(i.value ? "expanded" : "collapsed"), c = (e) => f.value = e;
    function N() {
      return i.value ? p : l.value === 0 ? Y : v.value;
    }
    const g = E(N()), s = (e) => g.value = e, r = (e) => s({ ...g.value, ...e }), w = S(V), T = (e) => w.value = e, A = x(() => ({ [R]: `${w.value}ms` }));
    let d = NaN;
    function m() {
      s(p), c("expanded"), u("expanded");
    }
    function y() {
      s(v.value), c("collapsed"), u("collapsed");
    }
    I(() => {
      if (!t.value)
        return;
      const e = K(t.value.scrollHeight - l.value);
      e > 0 && T(e), !i.value && l.value === 0 && s(v.value);
    }), _(i, (e) => {
      if (t.value)
        if (d = NaN, e) {
          if (b(t))
            return m();
          c("expanding"), u("expand"), s({
            ...p,
            ...h.value,
            ...A.value
          }), requestAnimationFrame(() => {
            if (t.value.scrollHeight === 0)
              return m();
            d = t.value.scrollHeight, r({
              ...D(t),
              height: `${d}px`,
              willChange: "height"
            });
          });
        } else {
          if (b(t) || (c("collapsing"), u("collapse"), r({
            ...A.value,
            height: `${t.value.scrollHeight}px`
          }), t.value.scrollHeight === 0))
            return y();
          requestAnimationFrame(() => {
            r({
              ...h.value,
              ...D(t),
              willChange: "height"
            });
          });
        }
    }), _(l, (e) => {
      i.value || (e > 0 ? r({ display: void 0, height: `${e}px` }) : r({ display: "none" }));
    });
    function F(e) {
      e.target && e.target === t.value && e.propertyName === "height" && (i.value ? Math.abs(t.value.scrollHeight - C(t)) < 1 ? m() : d < t.value.scrollHeight && r({
        height: `${t.value.scrollHeight}px`
      }) : Math.abs(l.value - C(t)) < 1 && y());
    }
    return (e, j) => (L(), M(U(o.as), {
      ref_key: "collapseRef",
      ref: t,
      style: O(g.value),
      onTransitionend: F,
      "data-collapse": f.value
    }, {
      default: k(() => [
        q(e.$slots, "default", z(B({ state: f.value })))
      ]),
      _: 3
    }, 40, ["style", "data-collapse"]));
  }
});
export {
  J as Collapse
};
